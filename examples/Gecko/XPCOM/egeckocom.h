/* $Id$ */

#ifndef EGECKOCOM_INC
#define EGECKOCOM_INC

#include "iegecko.h"	// Generated by 'xpidl'.
#include "str.h"
#include "nsxpcm.h"
#include "lstbch.h"
#include "tol.h"

#define EGECKOCOM_CONTRACTID "@zeusw.org/egeckocom;1"
#define EGECKOCOM_CLASSNAME "EGeckocom"
// {f1e695a0-b2f1-4a30-ac62-48a9edd9558a}
#define EGECKOCOM_CID  IEGECKOCOM_IID

E_ROW( krow__ );

class bridge__
{
private:
	krow__ _KernelRow;
public:
	void reset( bso::bool__ = true )
	{
		_KernelRow = NONE;
	}
	bridge__()
	{
		reset( false );
	}
	~bridge__()
	{
		reset();
	}
	void Init( krow__ KernelRow )
	{
#ifdef XXX_DBG
		if ( _KernelRow != NONE )
			ERRu();
#endif
		reset();

		_KernelRow = KernelRow;
	}
	const class kernel___ &Kernel( void ) const;
	class kernel___ &Kernel( void );
	const class ui__ &UI( void ) const;
	class ui__ &UI( void );
};

class ui_textbox__
: public nsxpcm::textbox__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void );
/*	{
	ERRProlog
		str::string Value;
	ERRBegin
		Value.Init();
		this->GetValue( Value );
		nsxpcm::Log( Value );

//		this->Kernel().Propagate();
		epeios::row__ Row = Global.First();

		while ( Row != NONE ) {
			Global( Row )->Set( Value );

			Row = Global.Next( Row );
		}
	ERRErr
	ERREnd
	ERREpilog
	}
*/	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::button__::Init()' called later.
	}
};

typedef ui_textbox__	ui_input_textbox__;

class ui_label__
: public nsxpcm::label__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::label__::Init()' called later.
	}
};

typedef ui_label__	ui_output_label__;

class ui_checkbox__
: public nsxpcm::checkbox__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::checkbox__::Init()' called later.
	}
};

typedef ui_checkbox__	ui_shared_checkbox__;

class ui_button__
: public nsxpcm::button__,
  public bridge__
{
protected:
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::button__::Init()' called later.
	}
};

class ui_error_button__
: public ui_button__
{
protected:
	virtual void NSXPCMOnCommand( void ) {}
	virtual void NSXPCMOnClick( void );
};

class ui__
{
public:
	struct main {
		nsIDOMDocument *Document;
		nsIDOMWindow *Window;
		ui_input_textbox__ Input;
		ui_shared_checkbox__ Shared;
		ui_output_label__ Output;
	} Main;
	struct page {
		nsIDOMDocument *Document;
		nsIDOMWindow *Window;
		ui_error_button__ Error;
	} Page;
	void Init( void )
	{}
};

class kernel___
{
private:
	str::string _Text;
public:
	ui__ UI;
	void reset( bso::bool__ P = true )
	{
		_Text.reset( P );
	}
	kernel___()
	{
		reset( false );
	}
	~kernel___()
	{
		reset();
	}
	void Init( void )
	{
		reset();

		_Text.Init();

		UI.Init();

	}
	void InputToOutput( void )
	{
	ERRProlog
		str::string Value;
	ERRBegin
		Value.Init();
		UI.Main.Input.GetValue( Value );
		UI.Main.Output.SetValue( Value );
	ERRErr
	ERREnd
	ERREpilog
	}
	void InputToAllOutputs( void );
};

inline void ui_input_textbox__::NSXPCMOnInput( void )
{
	if ( UI().Main.Shared.IsChecked() )
		Kernel().InputToAllOutputs();
	else
		Kernel().InputToOutput();
}

template <typename user_type, typename user_row> E_TTYPEDEF( lstbch::E_LBUNCHt_( user_type *, user_row ), _lpbunch_ );	// 'List Pointer Bunch'.

template <typename user_type, typename user_row> class global_
: public _lpbunch_<user_type, user_row>
{
public:
	struct s
	: _lpbunch_<user_type, user_row>::s
	{
		user_row Row;
	} &S_;
	void reset( bso::bool__ P = true )
	{
		if ( P ) {
			if ( Amount() != 0 )
				ERRu();	// Car des objets existent qui n'ont pas encore été supprimé ('delete'r).
		}

		_lpbunch_<user_type, user_row>::reset( P );
		S_.Row = NONE;
	}
	global_( s &S )
	: S_( S ),
	  _lpbunch_<user_type, user_row>( S )
	{}
	void plug( mmm::E_MULTIMEMORY_ &MMM )
	{
		_lbunch_<user_type *, user_row>::plug();
	}
	global_ &operator =( const global_ &G )
	{
		_lbunch_<user_type *, user_row>::operator =( *this );
		S_.Row = G.S_.Row;

		return *this;
	}
	void Init( void )
	{
		reset();
		_lpbunch_<user_type, user_row>::Init();
	}
	void CreateNewObject( void )
	{
		user_type *UserObject = NULL;

		if ( S_.Row != NONE )
			ERRu();

		if ( ( UserObject = new user_type ) == NULL )
			ERRa();

		S_.Row = Add( UserObject );

		Get( S_.Row )->Init();
	}
	void DismissCurrentObject( void )
	{
		if ( S_.Row == NONE )
			ERRu();

		S_.Row = NONE;
	}
	user_row GetCurrentRow( void ) const
	{
		if ( S_.Row == NONE )
			ERRu();

		return S_.Row;
	}
	user_type &GetCurrentObject( void ) const
	{
		return *Get( GetCurrentRow() );
	}
	void Delete( user_row Row )
	{
#ifdef XXX_DBG
		if ( !Exists( Row ) )
			ERRu();
#endif
		delete Get( Row );

		Store( NULL, Row );

		_lpbunch_<user_type, user_row>::Delete( Row );

	}
};

E_AUTO2( global )

extern global<kernel___, krow__ > Global;

inline kernel___ &bridge__::Kernel( void )
{
	return *Global.Get( _KernelRow );
}

inline ui__ &bridge__::UI( void )
{
	return Kernel().UI;
}

inline void kernel___::InputToAllOutputs( void )
{
ERRProlog
	str::string Value;
ERRBegin
	Value.Init();
	UI.Main.Input.GetValue( Value );

	krow__ Row = Global.First();

	while ( Row != NONE ) {

		Global.Get( Row )->UI.Main.Output.SetValue( Value );

		Row = Global.Next( Row );
	}

ERRErr
ERREnd
ERREpilog
}

#include "nsIDOMNodeList.h"
#include "nsIDOMWindow.h"
#include "toolkitcomps/nsICommandLineRunner.h"

void ui_error_button__::NSXPCMOnClick( void )
{

	nsCOMPtr<nsICommandLine> CommandLine = NULL;
	nsresult Result = NS_OK;
	PRInt32 Length = 32;

	nsCID CID = NS_ICOMMANDLINE_IID;

//	CommandLine = do_GetService( CID, &Result );

//	nsxpcm::GetService<nsICommandLine>( "@mozilla.org/toolkit/command-line;1", CommandLine );

//	nsxpcm::CreateInstance<nsICommandLineRunner>( "@mozilla.org/toolkit/command-line;1", CommandLine );

	CommandLine = nsxpcm::QueryInterface<nsICommandLine>( this->Kernel().UI.Page.Window );


	CommandLine->GetLength( &Length );

//	nsxpcm::QueryInterface<nsIDOMWindowInternal>( UI().Window )->Alert( NS_LITERAL_STRING( "Yesss !" ) );
	ERRu();
}




class egeckocom
: public iegeckocom
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_IEGECKOCOM

  egeckocom();
  krow__ _KernelRow;
private:
  ~egeckocom();
protected:
  /* additional members */
};

#endif