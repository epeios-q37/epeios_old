/* $Id$ */

#ifndef EGECKOCOM_INC
#define EGECKOCOM_INC

#include "iegecko.h"	// Generated by 'xpidl'.
#include "str.h"
#include "nsxpcm.h"
#include "lstbch.h"
#include "tol.h"

#define VERSION __DATE__ " " __TIME__

#define EGECKOCOM_CONTRACTID "@zeusw.org/egeckocom;1"
#define EGECKOCOM_CLASSNAME "EGeckocom"
// {f1e695a0-b2f1-4a30-ac62-48a9edd9558a}
#define EGECKOCOM_CID  IEGECKOCOM_IID

E_ROW( krow__ );

class bridge__
{
private:
	krow__ _KernelRow;
public:
	void reset( bso::bool__ = true )
	{
		_KernelRow = NONE;
	}
	bridge__()
	{
		reset( false );
	}
	~bridge__()
	{
		reset();
	}
	void Init( krow__ KernelRow )
	{
#ifdef XXX_DBG
		if ( _KernelRow != NONE )
			ERRu();
#endif
		reset();

		_KernelRow = KernelRow;
	}
	const class kernel___ &Kernel( void ) const;
	class kernel___ &Kernel( void );
	const class ui__ &UI( void ) const;
	class ui__ &UI( void );
};

class ui_textbox__
: public nsxpcm::textbox__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void );
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::button__::Init()' called later.
	}
};

typedef ui_textbox__	ui_input_textbox__;

class ui_label__
: public nsxpcm::label__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::label__::Init()' called later.
	}
};

typedef ui_label__	ui_output_label__;

class ui_checkbox__
: public nsxpcm::checkbox__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::checkbox__::Init()' called later.
	}
};

typedef ui_checkbox__	ui_shared_checkbox__;

class ui_button__
: public nsxpcm::button__,
  public bridge__
{
protected:
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::button__::Init()' called later.
	}
};

class ui_error_button__
: public ui_button__
{
protected:
	virtual void NSXPCMOnCommand( void );
};

class ui_jsconsole_button__
: public ui_button__
{
protected:
	virtual void NSXPCMOnCommand( void );
};

class ui_xslt_button__
: public ui_button__
{
protected:
	virtual void NSXPCMOnCommand( void );
};


class ui_description__
: public nsxpcm::description__,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void ){}
	virtual void NSXPCMOnClick( void ){}
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::description__::Init()' called later.
	}
};

typedef ui_description__ ui_endianess_description__;

#include "nsIDOMHTMLAnchorElement.h"

class ui_link__
: public nsxpcm::_element__<nsIDOMHTMLAnchorElement>,
  public bridge__
{
protected:
	virtual void NSXPCMOnCommand( void );
	virtual void NSXPCMOnClick( void );
	virtual void NSXPCMOnInput( void ){}
	virtual void NSXPCMOnFocus( void ){}
	virtual void NSXPCMOnBlur( void ){}
public:
	void Init( krow__ KernelRow )
	{
		bridge__::Init( KernelRow );
		// 'nsxpcm::description__::Init()' called later.
	}
};


class ui__
{
public:
	struct main {
		nsIDOMDocument *Document;
		nsIDOMWindow *Window;
		ui_input_textbox__ Input;
		ui_shared_checkbox__ Shared;
		ui_output_label__ Output;
		ui_jsconsole_button__ JSConsole;
		ui_xslt_button__ XSLT;
		ui_endianess_description__ Endianess;
		main( void )
		{
			Document = NULL;
			Window = NULL;
		}
	} Main;
	struct page {
		nsIDOMDocument *Document;
		nsIDOMWindow *Window;
		ui_error_button__ Error;
		ui_link__ Link;
		page( void )
		{
			Document = NULL;
			Window = NULL;
		}
	} Page;
	void Init( void )
	{}
};

class kernel___
{
private:
	str::string _Text;
public:
	ui__ UI;
	void reset( bso::bool__ P = true )
	{
		_Text.reset( P );
	}
	kernel___()
	{
		reset( false );
	}
	~kernel___()
	{
		reset();
	}
	void Init( void )
	{
		reset();

		_Text.Init();

		UI.Init();

	}
	void InputToOutput( void )
	{
	ERRProlog
		str::string Value;
	ERRBegin
		Value.Init();
		UI.Main.Input.GetValue( Value );
		UI.Main.Output.SetValue( Value );
	ERRErr
	ERREnd
	ERREpilog
	}
	void InputToAllOutputs( void );
	void OpenJSConsole( void );
	void DisplayEndianess( void );
	void Alert( const str::string_ &Message )
	{
		nsxpcm::Alert( UI.Main.Window, Message );
	}
	void Alert( const char *Message )
	{
		nsxpcm::Alert( UI.Main.Window, Message );
	}
};

template <typename user_type, typename user_row> E_TTYPEDEF( lstbch::E_LBUNCHt_( user_type *, user_row ), _lpbunch_ );	// 'List Pointer Bunch'.

template <typename user_type, typename user_row> class global_
: public _lpbunch_<user_type, user_row>
{
public:
	struct s
	: _lpbunch_<user_type, user_row>::s
	{
		user_row Row;
	} &S_;
	void reset( bso::bool__ P = true )
	{
		if ( P ) {
			if ( _lpbunch_<user_type, user_row>::Amount() != 0 )
				ERRu();	// Car des objets existent qui n'ont pas encore été supprimé ('delete'r).
		}

		_lpbunch_<user_type, user_row>::reset( P );
		S_.Row = NONE;
	}
	global_( s &S )
	: S_( S ),
	  _lpbunch_<user_type, user_row>( S )
	{}
	void plug( mmm::E_MULTIMEMORY_ &MMM )
	{
		_lpbunch_<user_type *, user_row>::plug();
	}
	global_ &operator =( const global_ &G )
	{
		_lpbunch_<user_type *, user_row>::operator =( *this );
		S_.Row = G.S_.Row;

		return *this;
	}
	void Init( void )
	{
		reset();
		_lpbunch_<user_type, user_row>::Init();
	}
	void CreateNewObject( void )
	{
		user_type *UserObject = NULL;

		if ( S_.Row != NONE )
			ERRu();

		if ( ( UserObject = new user_type ) == NULL )
			ERRa();

		S_.Row = Add( UserObject );

		Get( S_.Row )->Init();
	}
	void DismissCurrentObject( void )
	{
		if ( S_.Row == NONE )
			ERRu();

		S_.Row = NONE;
	}
	user_row GetCurrentRow( void ) const
	{
		if ( S_.Row == NONE )
			ERRu();

		return S_.Row;
	}
	user_type &GetCurrentObject( void ) const
	{
		return *Get( GetCurrentRow() );
	}
	void Delete( user_row Row )
	{
#ifdef XXX_DBG
		if ( !Exists( Row ) )
			ERRu();
#endif
		delete Get( Row );

		Store( NULL, Row );

		_lpbunch_<user_type, user_row>::Delete( Row );

	}
};

E_AUTO2( global )

extern global<kernel___, krow__ > Global;

inline kernel___ &bridge__::Kernel( void )
{
	return *Global.Get( _KernelRow );
}

inline ui__ &bridge__::UI( void )
{
	return Kernel().UI;
}


class egeckocom
: public iegeckocom
{
public:
  NS_DECL_ISUPPORTS
  NS_DECL_IEGECKOCOM

  egeckocom();
  krow__ _KernelRow;
private:
  ~egeckocom();
protected:
  /* additional members */
};

#endif